# **Learning Summary — Data Engineering & Software Development (Verified Concepts)**

## **1. Python Project Structure**

### **1.1 The `src/` Layout (Industry Standard)**
Python projects should use the following structure:

```
project_root/
├── pyproject.toml
├── README.md
└── src/
    └── your_package/
        ├── main.py
        ├── utils/
        ├── scrapers/
        ├── db/
        └── __init__.py
```

**Key reasons:**

- Prevents import confusion  
- Separates source code from project configuration  
- Matches modern packaging expectations  

---

## **2. Understanding `__init__.py`**

### **2.1 Purpose**
`__init__.py` marks a directory as a Python **package**, allowing imports such as:

```python
from your_package.utils.http import fetch_html
```

### **2.2 Typical Usage**
- Usually **empty**
- Only include imports when intentionally designing a package-level API
- Avoid unnecessary imports to prevent circular dependencies

---

## **3. Virtual Environments (`.venv`)**

- Virtual environments contain project-specific dependencies  
- Should **not** be committed to Git  
- Must be **ignored** using `.gitignore`  
- uv creates `.venv` *only* when dependencies are installed or `uv venv` is called (not during `uv init`)

---

## **4. `.gitignore` Best Practices**

### **4.1 Purpose**
`.gitignore` tells Git what to **exclude** from version control.

### **4.2 Common Patterns to Ignore**
```
# Python cache
__pycache__/
*.pyc

# Virtual envs
.venv/
venv/
env/

# Build artifacts
dist/
build/
*.egg-info/

# Secrets
.env
.env.*

# Editor/OS files
.vscode/
.idea/
.DS_Store
Thumbs.db
```

These patterns prevent tracking:

- Machine-specific files  
- Editor configs  
- Secrets  
- Generated code  
- Build output  

---

## **5. Why You Don’t See Certain Files Yet**

Many files listed in `.gitignore` do **not** exist until:

| File or Folder | When It Appears |
|----------------|----------------|
| `__pycache__/` | After running Python via *standard* interpreter |
| `.vscode/` | After opening project in VS Code |
| `.env` | When you create environment variables |
| `dist/`, `build/` | After packaging your project |
| Docker volumes | After running containers |

uv often runs code without generating bytecode caches, so `__pycache__/` may not appear.

---

## **6. Modular Code Design**

- Keep `main.py` small  
- Move logic into domain-specific modules:  
  - `utils/` for helpers  
  - `scrapers/` for web scraping  
  - `db/` for database interaction  
- Improves clarity, reuse, and maintainability

---

## **7. Useful Commands and Patterns**

### **7.1 Terminal Commands**
| Command | Purpose |
|---------|---------|
| `uv init` | Initialize a Python project |
| `uv run script.py` | Run Python through uv |
| `uv venv` | Create a virtual environment |
| `uv add package` | Install a package |
| `touch file.py` | Create an empty file |
| `mkdir folder` | Create a directory |
| `mv old new` | Move/rename a file |
| `git add .` | Stage all unignored files |
| `git status` | Show file changes |

---

### **7.2 Python Packaging Concepts**
| Concept | Description |
|--------|-------------|
| `__init__.py` | Marks a folder as a package |
| `src/` layout | Recommended project structure |
| `main.py` | Entry point for orchestration |
| Modular imports | Improves organization and reusability |

---

## **8. Key Lessons to Revisit**

- Python import mechanics  
- Why `src/` layout prevents mistakes  
- Purpose of `__init__.py` as a package marker  
- When uv creates `.venv` and why  
- What `.gitignore` does (and doesn't) do  
- How project modules should be organized  
- Why not all gitignored files appear immediately  

---
